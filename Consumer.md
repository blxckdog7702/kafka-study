# Consumer  

카프카 클러스터에서 레코드를 읽는 클라이언트를 말한다.  

## Consumer 구성 방법  

처리할 때 의도적으로 particular threading model을 채택하지 않았다. 레코드를 다중 스레드로 처리하기 위한 몇 가지 옵션을 가져갈 수 있기 때문이다.  

1. One Consumer Per Thread  
- 장점 : 구현하기 쉽다, 대체로 빠르고 inter-thread co-ordination이 필요없다, 파티션 별 in-order 처리 구현이 쉽다.
- 단점 : Consumer가 많을수록 클러스터에 TCP connection이 많아진다. 일반적으로 카프카는 connection을 효율적으로 처리하기 때문에 적은 비용이 소모된다
- 단점 : Consumer가 많다는건 많은 요청이 서버에 보내지고 배치량이 약간 줄어든다는 의미이다. 그리고 이는 I/O 처리량이 줄어드는 원인이 될 수 있다.
- 단점 : 프로세스에 연관된 전체 스레드의 개수는 전체 파티션의 개수로 제한된다.

2. Decouple Consumption and Processing  
다른 방법은 한 개 이상의 Consumer 스레드를 갖는 것이다. 이 스레드는 모든 데이터 소비를 해서, 블로킹 큐에 ConsuemrRecord 인스턴스를 전달한다. 이 블로킹 큐는 프로세서 스레드 풀에 의해서 소비된다. 실제로 이 프로세서 스레드들에 의해 레코드 프로세싱이 이루어진다.  
- 장점 : Consumer와 Processor의 크기를 독립적으로 구성할 수 있다. 파티션 제한 없이, 한 Consumer에 여러 프로세서 스레드가 물릴 수 있다.
- 단점 : 각 스레드가 독립적으로 실행되기 때문에 프로세서간 처리 순서를 보장할 수 없다.
- 단점 : 수동으로 position을 커밋하기가 어렵다. 모든 스레드의 파티션 처리가 완료되도록 조정해야하기 때문이다.

이런 구성 방법에는 여러 variation이 있다. 예를 들면 모든 프로세서 스레드가 각각 큐를 가지고 있고, 컨슈머 스레드는 토픽 파티션을 이용해 이 큐들에 해시를 할 수 있다. 그러면 순서를 보장하는 소비가 가능해지고, 커밋을 단순화 할 수 있다.