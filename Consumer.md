# Consumer  

카프카 클러스터에서 레코드를 읽는 클라이언트를 말한다.  

## 컨슈머 주요 옵션  
- 올드 컨슈머 : 주키퍼에서 컨슈머 오프셋을 받아오는 방식(deprecated)
- 뉴 컨슈머 : 카프카의 토픽에서 컨슈머 오프셋을 받아오는 방식
- session.timout.ms : 이 시간 만큼 컨슈머가 그룹 코디네이터에게 하트비트를 보내지 않으면 종료되거나 장애 발생으로 간주하고 리밸런싱을 시도한다. 이 시간을 짧게 설정하면 실패를 빨리 감지할 수 있지만, GC나 poll 루프 시간이 오래 걸릴 경우 원치 않는 리밸런싱이 발생한다. 그리고 시간을 길게 설정하면 실제 오류를 감지하는 데 시간이 오래 걸릴 수 있다.  
- heartbeat.interval.ms : 그룹 코디네이터에게 얼마나 자주 `poll()` 메서드로 하트비트를 보낼지 조정한다. 일반적으로 session.timout.ms의 3분의 1 수준으로 설정함.

## 커밋과 오프셋  

### 자동 커밋  
컨슈머 1이 12,34,56 단위로 `poll()`을 하고 커밋을 하는 시나리오에서, 56을 컨슘해서 처리하고 커밋을 기다리고 있을 때 갑자기 리밸런싱이 일어나서 컨슈머 2가 붙은 상황이다. 아직 메시지 56은 커밋이 되지 않았기 때문에 컨슈머 2는 56을 다시 컨슘하게 되고, 메시지 56은 로직에서 중복으로 처리된다.  

### 수동 커밋  
자동 커밋은 위 처럼 중복 또는 손실이 발생할 가능성이 있다. 그래서 메시지가 처리 로직(DB insert 등)을 타고 난 뒤에 수동으로 커밋을 해주는게 더 안전할 수 있다.  

## Consumer 구성 방법  

처리할 때 의도적으로 particular threading model을 채택하지 않았다. 레코드를 다중 스레드로 처리하기 위한 몇 가지 옵션을 가져갈 수 있기 때문이다.  

1. One Consumer Per Thread  
- 장점 : 구현하기 쉽다, 대체로 빠르고 inter-thread co-ordination이 필요없다, 파티션 별 in-order 처리 구현이 쉽다.
- 단점 : Consumer가 많을수록 클러스터에 TCP connection이 많아진다. 일반적으로 카프카는 connection을 효율적으로 처리하기 때문에 적은 비용이 소모된다
- 단점 : Consumer가 많다는건 많은 요청이 서버에 보내지고 배치량이 약간 줄어든다는 의미이다. 그리고 이는 I/O 처리량이 줄어드는 원인이 될 수 있다.
- 단점 : 프로세스에 연관된 전체 스레드의 개수는 전체 파티션의 개수로 제한된다.

2. Decouple Consumption and Processing  
다른 방법은 한 개 이상의 Consumer 스레드를 갖는 것이다. 이 스레드는 모든 데이터 소비를 해서, 블로킹 큐에 ConsuemrRecord 인스턴스를 전달한다. 이 블로킹 큐는 프로세서 스레드 풀에 의해서 소비된다. 실제로 이 프로세서 스레드들에 의해 레코드 프로세싱이 이루어진다.  
- 장점 : Consumer와 Processor의 크기를 독립적으로 구성할 수 있다. 파티션 제한 없이, 한 Consumer에 여러 프로세서 스레드가 물릴 수 있다.
- 단점 : 각 스레드가 독립적으로 실행되기 때문에 프로세서간 처리 순서를 보장할 수 없다.
- 단점 : 수동으로 position을 커밋하기가 어렵다. 모든 스레드의 파티션 처리가 완료되도록 조정해야하기 때문이다.

이런 구성 방법에는 여러 variation이 있다. 예를 들면 모든 프로세서 스레드가 각각 큐를 가지고 있고, 컨슈머 스레드는 토픽 파티션을 이용해 이 큐들에 해시를 할 수 있다. 그러면 순서를 보장하는 소비가 가능해지고, 커밋을 단순화 할 수 있다.

[출처] : 고승범, 공용준, *카프카, 데이터 플랫폼의 최강자* (책만, 2018)  